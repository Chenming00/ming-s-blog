<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on Vincent&#39;s Notes</title>
    <link>https://blog.qwq.mx/posts/</link>
    <description>Recent content in Posts on Vincent&#39;s Notes</description>
    <image>
      <url>https://blog.qwq.mx/papermod-cover.png</url>
      <link>https://blog.qwq.mx/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 04 Feb 2023 07:19:16 +0800</lastBuildDate><atom:link href="https://blog.qwq.mx/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>My First Post</title>
      <link>https://blog.qwq.mx/posts/my-first-post/</link>
      <pubDate>Sat, 04 Feb 2023 07:19:16 +0800</pubDate>
      
      <guid>https://blog.qwq.mx/posts/my-first-post/</guid>
      <description>正常情况下，在iOS设备上是不可能安装两个一模一样的App。但是大部分人对于微信这款App都希望能够有2个及以上。工作和个人两个号，互不打扰。也能够及时的看到两个账号的消息，这是最完美的事情。
如果要做到以上的情况需要怎么做呢，大部分的选择可能是去某宝购买。某宝的价格基本上在40-100元不等，非常昂贵。平均下来，买一次最多使用1-3个月左右。淘宝售卖的是各种品牌的微信多开，但是按大类来分，无非就是两种，TestFlight(TF)和企业证书。我不展开说这两个版本有什么区别，如果要我硬是选择一个更好的，我会选择TF版本。
既然某宝那么贵到底成本有多少呢，理论上除去开发成本，成本应该只有一个Apple Developer订阅的账号(688元)的成本吧。因此，会有很多叫做卡密网的网站以非常低的价格售卖微信多开。基本上价格在5-40元之间，10-20元居多。我曾经也买了很多次，最后总结的经验就是，基本上在三个月之内，作者必定会跑路。也就是意味着你三个月之后就用不了了，而且最恶心的事情是，作者会更换一个名字，三个月后重新开始售卖。典型的改名继续圈钱。
正常的流程，买的是一个激活码，然后第一次打开这个多开的时候，需要输入激活码进行验证。验证成功后可以正常使用。我想，是否有办法去绕过这个验证呢？
直接屏蔽验证接口 一般情况下，作者为了控制激活码的有效性，简单来说，如果你退款了，他可以立刻封禁你的激活码让你无法使用。所以他们一般会在每次打开App的时候，向服务器发起一个请求，如果服务端验证通过，会返回一些东西，例如“成功”等等。这种验证方式，其实还是有办法解决的，我们只要拿到正常的激活码，Response的内容是什么，我们通过强大的QuanX或者Surge这类工具，开启MITM，重写Response即可。在我测试的过程中，有遇到过直接Reject接口也可以绕过验证。
1 DOMAIN-SUFFIX, xxx.com, Reject 当然有些开发者可能已经考虑到我们会这样做，于是他直接将验证的代码写在了本地。这类程序几乎是无法绕过的。
自己获取激活码 由于被薅过太多次羊毛，每次三个月就跑路。我就开始想，有没有办法薅作者的羊毛。初步的想法是搞明白作者的激活码的规律。但是这显然不靠谱，因为这些基本随机生成的，当然肯定有一定的规律，只是我们不是开发者本人，几乎是不可能猜到的。
既然找不到规律，就只能开始暴力破解。我发现大部分的多开的激活码都是YW-XXXXXX，前面两个字母是产品名字的首字母，例如云微是YW，云彩是YC等等。然后后面的这一串XXXXXX是随机的六个字母。也就是说激活码的可能性只存在于AAAAAA-ZZZZZZ之中。这个可能性非常大，但是交给我们的服务器去做，简直是小菜一碟。
1 2 3 4 5 6 pool = threadpool.ThreadPool(99) while True: code = create_code() tasks = threadpool.makeRequests(run, code) [pool.putRequest(req) for req in tasks] pool.wait() 我开始编写脚本，采用多线程的方案去尝试。效果非常好，几分钟出现很多验证通过的结果。服务器运行24小时，可以出现上千个激活码。于是我就有了用不完的激活码，成功薅到了作者的羊毛。</description>
      <content:encoded><![CDATA[<p>正常情况下，在iOS设备上是不可能安装两个一模一样的App。但是大部分人对于<code>微信</code>这款App都希望能够有2个及以上。工作和个人两个号，互不打扰。也能够及时的看到两个账号的消息，这是最完美的事情。</p>
<p>如果要做到以上的情况需要怎么做呢，大部分的选择可能是去某宝购买。某宝的价格基本上在40-100元不等，非常昂贵。平均下来，买一次最多使用1-3个月左右。淘宝售卖的是各种品牌的微信多开，但是按大类来分，无非就是两种，<code>TestFlight(TF)</code>和<code>企业证书</code>。我不展开说这两个版本有什么区别，如果要我硬是选择一个更好的，我会选择TF版本。</p>
<p>既然某宝那么贵到底成本有多少呢，理论上除去开发成本，成本应该只有一个Apple Developer订阅的账号(688元)的成本吧。因此，会有很多叫做<code>卡密网</code>的网站以非常低的价格售卖微信多开。基本上价格在5-40元之间，10-20元居多。我曾经也买了很多次，最后总结的经验就是，基本上在三个月之内，作者必定会跑路。也就是意味着你三个月之后就用不了了，而且最恶心的事情是，作者会更换一个名字，三个月后重新开始售卖。典型的改名继续圈钱。</p>
<p>正常的流程，买的是一个激活码，然后第一次打开这个多开的时候，需要输入激活码进行验证。验证成功后可以正常使用。我想，是否有办法去绕过这个验证呢？</p>
<h3 id="直接屏蔽验证接口">直接屏蔽验证接口</h3>
<p>一般情况下，作者为了控制激活码的有效性，简单来说，如果你退款了，他可以立刻封禁你的激活码让你无法使用。所以他们一般会在每次打开App的时候，向服务器发起一个请求，如果服务端验证通过，会返回一些东西，例如“成功”等等。这种验证方式，其实还是有办法解决的，我们只要拿到正常的激活码，<code>Response</code>的内容是什么，我们通过强大的<code>QuanX</code>或者<code>Surge</code>这类工具，开启<code>MITM</code>，重写<code>Response</code>即可。在我测试的过程中，有遇到过直接<code>Reject</code>接口也可以绕过验证。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-0-1"><a class="lnlinks" href="#hl-0-1">1</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">DOMAIN-SUFFIX, xxx.com, Reject
</span></span></code></pre></td></tr></table>
</div>
</div><p>当然有些开发者可能已经考虑到我们会这样做，于是他直接将验证的代码写在了本地。这类程序几乎是无法绕过的。</p>
<h3 id="自己获取激活码">自己获取激活码</h3>
<p>由于被薅过太多次羊毛，每次三个月就跑路。我就开始想，有没有办法薅作者的羊毛。初步的想法是搞明白作者的激活码的规律。但是这显然不靠谱，因为这些基本随机生成的，当然肯定有一定的规律，只是我们不是开发者本人，几乎是不可能猜到的。</p>
<p>既然找不到规律，就只能开始暴力破解。我发现大部分的多开的激活码都是<code>YW-XXXXXX</code>，前面两个字母是产品名字的首字母，例如云微是<code>YW</code>，云彩是<code>YC</code>等等。然后后面的这一串<code>XXXXXX</code>是随机的六个字母。也就是说激活码的可能性只存在于<code>AAAAAA</code>-<code>ZZZZZZ</code>之中。这个可能性非常大，但是交给我们的服务器去做，简直是小菜一碟。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-1-1"><a class="lnlinks" href="#hl-1-1">1</a>
</span><span class="lnt" id="hl-1-2"><a class="lnlinks" href="#hl-1-2">2</a>
</span><span class="lnt" id="hl-1-3"><a class="lnlinks" href="#hl-1-3">3</a>
</span><span class="lnt" id="hl-1-4"><a class="lnlinks" href="#hl-1-4">4</a>
</span><span class="lnt" id="hl-1-5"><a class="lnlinks" href="#hl-1-5">5</a>
</span><span class="lnt" id="hl-1-6"><a class="lnlinks" href="#hl-1-6">6</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">pool = threadpool.ThreadPool(99)
</span></span><span class="line"><span class="cl">while True:
</span></span><span class="line"><span class="cl">	code = create_code()
</span></span><span class="line"><span class="cl">	tasks = threadpool.makeRequests(run, code)
</span></span><span class="line"><span class="cl">	[pool.putRequest(req) for req in tasks]
</span></span><span class="line"><span class="cl">	pool.wait()
</span></span></code></pre></td></tr></table>
</div>
</div><p>我开始编写脚本，采用多线程的方案去尝试。效果非常好，几分钟出现很多验证通过的结果。服务器运行24小时，可以出现上千个激活码。于是我就有了用不完的激活码，成功薅到了作者的羊毛。</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
